<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Fixed-point package User’s Guide &mdash; VHDL Numerical User Guides latest documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Floating-point package User’s Guide" href="float.html" />
    <link rel="prev" title="Contexts" href="../ieee/contexts.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> VHDL Numerical User Guides
          </a>
              <div class="version">
                latest
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">IEEE Libraries</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ieee/bit.html">Bit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ieee/std_logic.html">Std_logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ieee/numeric_std.html">Numeric_std</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ieee/math.html">Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ieee/fp.html">Fixed-point and floating-point</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ieee/contexts.html">Contexts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guides</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Fixed-point package User’s Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#literals-type-conversions">Literals &amp; Type conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sizing-rules">Sizing Rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#overloading">Overloading</a></li>
<li class="toctree-l2"><a class="reference internal" href="#package-generics">Package Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#issues">Issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="#index">Index</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#operators">Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conversion-functions">Conversion functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sizing-functions">Sizing functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#textio-functions">Textio Functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="float.html">Floating-point package User’s Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">VHDL Numerical User Guides</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
        
          
            <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Fixed-point package User’s Guide</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/umarcor/VHDLNumericUserGuides/blob/example/docs/dbishopx/fixed.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="fixed-point-package-user-s-guide">
<h1>Fixed-point package User’s Guide<a class="headerlink" href="#fixed-point-package-user-s-guide" title="Permalink to this heading">¶</a></h1>
<p><em>By David Bishop (dbishop&#64;vhdl.org)</em></p>
<p>Fixed point is a step between integer math and floating point.
This has the advantage of being almost as fast as numeric_std arithmetic, but able to represent numbers that are
less than 1.0.
A fixed-point number has an assigned width and an assigned location for the decimal point.
As long as the number is big enough to provide enough precision, fixed point is fine for most DSP applications.
Because it is based on integer math, it is extremely efficient – as long as the data does not vary too much in
magnitude.</p>
<p>The fixed point VHDL packages can be downloaded at: <a class="reference external" href="http://www.vhdl.org/fphld/vhdl.html">http://www.vhdl.org/fphld/vhdl.html</a></p>
<p>The files needed are “fixed_float_types.vhdl”, “fixed_generic_pkg.vhdl”, “fixed_generic_pkg-body.vhdl”, and
“fixed_pkg.vhdl”.
These packages have been designed for use in VHDL-2008, where they will be part of the new IEEE library.
However, a compatibility version of the packages is provided that works great in VHDL-1993, which is the version of
VHDL they were tested under.
They also have no dependencies to the other new VHDL packages.
The compatibility package is synthesizable.</p>
<p>The files on the web page to download are:</p>
<ul class="simple">
<li><p>fixed_float_types_c.vhdl - Types used in the fixed point package</p></li>
<li><p>fixed_pkg_c.vhdl - Fixed-point package (VHDL-93 compatibility version)</p></li>
</ul>
<p>This file should be compiled into a library called “ieee_proposed”.</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h2>
<p>This package defines two new types: “ufixed” is the unsigned fixed point, and “sfixed” is the signed
fixed point.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">ufixed</span> <span class="ow">is</span> <span class="n">array</span> <span class="p">(</span><span class="n">INTEGER</span> <span class="nb">range</span> <span class="o">&lt;&gt;</span><span class="p">)</span> <span class="n">of</span> <span class="n">STD_LOGIC</span><span class="p">;</span>
<span class="nb">type</span> <span class="n">sfixed</span> <span class="ow">is</span> <span class="n">array</span> <span class="p">(</span><span class="n">INTEGER</span> <span class="nb">range</span> <span class="o">&lt;&gt;</span><span class="p">)</span> <span class="n">of</span> <span class="n">STD_LOGIC</span><span class="p">;</span>
</pre></div>
</div>
<p>Usage model:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">use</span> <span class="n">ieee</span><span class="o">.</span><span class="n">fixed_float_types</span><span class="o">.</span><span class="n">all</span><span class="p">;</span> <span class="o">--</span> <span class="n">ieee_proposed</span> <span class="k">for</span> <span class="n">VHDL</span><span class="o">-</span><span class="mi">93</span> <span class="n">version</span>
<span class="n">use</span> <span class="n">ieee</span><span class="o">.</span><span class="n">fixed_pkg</span><span class="o">.</span><span class="n">all</span><span class="p">;</span> <span class="o">--</span> <span class="n">ieee_proposed</span> <span class="k">for</span> <span class="n">compatibility</span> <span class="n">version</span>
<span class="o">....</span>
<span class="n">signal</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">:</span> <span class="n">sfixed</span> <span class="p">(</span><span class="mi">7</span> <span class="n">downto</span> <span class="o">-</span><span class="mi">6</span><span class="p">);</span>
<span class="n">signal</span> <span class="n">c</span><span class="p">:</span> <span class="n">sfixed</span> <span class="p">(</span><span class="mi">8</span> <span class="n">downto</span> <span class="o">-</span><span class="mi">6</span><span class="p">);</span>
<span class="n">begin</span>
<span class="o">....</span>
<span class="n">c</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</pre></div>
</div>
<p>This data type shows you the location of the decimal point by using a negative index.
The decimal point is assumed to be between the “0” and “—1” index.
Thus, we can assume “signal y : ufixed (4 downto –5)” as the data type (unsigned fixed point, 10 bits wide,
5 bits of decimal), then <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">6.5</span> <span class="pre">=</span> <span class="pre">“00110.10000”</span></code>, or simply: <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">&quot;0011010000&quot;</span></code>;</p>
<p>Two other base data types are also defined in this package.
They are “UNRESOLVED_UFIXED” (aliased to “U_UFIXED”) and “UNRESOLVED_SFIXED” (aliased to “U_SFIXED”) which are
unresolved versions of the “UFIXED” and “SFIXED” types.
The data types “UNRESOLVED_UFIXED” and “UFIXED” can be mixed freely as they are subtypes of each other.
This is also true of the “UNRESOLVED_SFIXED” and “SFIXED” type.
Note that in the compatibility package “UNRESOLVED_UFIXED” is a subtype of “UFIXED” and “UNRESOLVED_SFIXED” is a
subtype of “SFIXED”, both of which are in reality resolved types.</p>
</section>
<section id="literals-type-conversions">
<h2>Literals &amp; Type conversions<a class="headerlink" href="#literals-type-conversions" title="Permalink to this heading">¶</a></h2>
<p>Conversion functions have been created for INTEGER, REAL, SIGNED, and UNSIGNED types.
These conversion functions can be called with two different sets of parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>a &lt;= to_sfixed (-3.125, 7, -6);
b &lt;= to_sfixed (inp1, b); -- returns “inp1” sized the same as “b”
</pre></div>
</div>
<p>You can also say:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">&lt;=</span> <span class="n">to_ufixed</span> <span class="p">(</span><span class="mf">6.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<p>where “4” is the upper index, and “—5” is the lower index; so you could also say:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">&lt;=</span> <span class="n">to_ufixed</span> <span class="p">(</span><span class="mf">6.5</span><span class="p">,</span> <span class="n">y</span><span class="s1">&#39;high, y&#39;</span><span class="n">low</span><span class="p">);</span>
</pre></div>
</div>
<p>further, there are also versions of these functions using the “size_res” parameter, so you can also say:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">&lt;=</span> <span class="n">to_ufixed</span> <span class="p">(</span><span class="mf">6.5</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</pre></div>
</div>
<p>The signed version uses a two’s complement to represent a negative number, just like the “numeric_std” package.
Any non-zero index range is valid. Thus:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">signal</span> <span class="n">z</span> <span class="p">:</span> <span class="n">ufixed</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="n">downto</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
<span class="n">z</span> <span class="o">&lt;=</span> <span class="s2">&quot;11&quot;</span><span class="p">;</span> <span class="o">--</span> <span class="mf">0.011</span> <span class="o">=</span> <span class="mf">0.375</span>
<span class="n">signal</span> <span class="n">x</span> <span class="p">:</span> <span class="n">sfixed</span> <span class="p">(</span><span class="mi">4</span> <span class="n">downto</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">y</span> <span class="o">&lt;=</span> <span class="s2">&quot;111&quot;</span><span class="p">;</span> <span class="o">--</span> <span class="mf">1110.0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">to_signed</span></code> and <code class="docutils literal notranslate"><span class="pre">to_unsigned</span></code> are also overloaded to take the “size_res” parameter as well as a “size”.
Rounding and saturation rules also apply on these functions.</p>
</section>
<section id="sizing-rules">
<h2>Sizing Rules<a class="headerlink" href="#sizing-rules" title="Permalink to this heading">¶</a></h2>
<p>The data widths in the fixed-point package were designed so that there is no possibility of an overflow.
This is a departure from the “numeric_std” model, which simply throws away underflow and overflow bits.</p>
<p>For unsigned fixed point:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>X &lt;= resize ( arg =&gt; X + 1,
left_index =&gt; X’high,
right_index =&gt; X’low,
round_style =&gt; fixed_truncate,
overflow_style =&gt; fixed_wrap);
</pre></div>
</div>
<p>“round_style” defaults to fixed_round (true) that turns on the rounding routines.
If false (fixed_truncate), the number is truncated.
Rounding is done by first looking to see if the MSB of the remainder is a “1”, AND the LSB of the unrounded
result is a “1” or the lower bits of the remainder include a “1”, the result will be rounded.
This is similar to the floating-point “round_nearest” style.
The down side is that ALL of the bits are included in the decision to round.</p>
<p>“overflow_style” default to fixed_saturate (true) that returns the maximum possible number, if the number is too
large to represent.
You can also set this to “fixed_wrap” (false) a “wrap” routine is used that simply truncates the top bits.
Unlike the way it is done in “numeric_std”, the sign bit is not preserved when wrapping.
Thus, it is possible to get positive result when resizing a negative number in this mode.</p>
<p>Finally, “guard_bits” defaults to “fixed_guard_bits”, which defaults to 3.
Guard bits are used in the rounding routines.
If guard is set to 0, the rounding is automatically turned off.
These extra bits are added to the end of the numbers in the division and “to_real” functions to make the numbers
more accurate.</p>
<p>Note that the default for both overflow_style and round_style is “true”.
This is true for all functions that use these parameters.</p>
</section>
<section id="overloading">
<h2>Overloading<a class="headerlink" href="#overloading" title="Permalink to this heading">¶</a></h2>
<p>The following operations are defined for ufixed:
+, –, <a href="#id1"><span class="problematic" id="id2">*</span></a>, /, rem, mod, =, /=, &lt;, &gt;, &gt;=, &lt;=, sll, srl, rol, ror, sla, sra</p>
<p>The following operations are defined for sfixed:
+, –, <a href="#id3"><span class="problematic" id="id4">*</span></a>, /, rem, mod, =, /=, &lt;, &gt;, &gt;=, &lt;=, sll, srl, rol, ror, sla, sra, abs, - (unary)</p>
<p>All of the operators are overloaded for “real” and “integer” data types.
In each case, the number is converted into fixed point before the operation is done.
Thus, the fixed-point operand must be of a format large enough to accommodate the converted input or a
“vector-truncated” warning is produced.
In these functions, “overflow_style” is set to “fixed_saturate” or “true”.</p>
<p>Thus you can say:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Signal x : sfixed (4 downto –5);
Signal y : real;
...
z := x + y;
</pre></div>
</div>
<p>In the case where an operation is performed that includes both a fixed-point number and an integer or
real, the sizing rules are modified.
For a real number, the real is converted to a fixed-point number that is the same size as the fixed-point number
that has been passed as the ot her argument.
Thus, in the above example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sfixed</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<p>would be called, which would result in Z being an “sfixed (5 downto –5)” type.
This is also true for integers.</p>
<p>Shift operators are functionally the same as the IEEE-1076-1993 shift operators with the exception of the
arithmetic shift operations.
An arithmetic shift (“sra”, or “sla”) on an unsigned number is the same as a logical shift.
An arithmetic shift on a signed number is a logical shift, if you are shifting left, and an arithmetic shift
(sign bit replicated), if you are shifting right.</p>
<p>The “scalb” function can be used to losslessly multiply or divide any number by a power of two.
Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>constant half : ufixed (2 downto –2) := “00010” – 000.10
variable two : ufixed (5 downto 0);
variable someval : ufixed (5 downto –5);
begin
two := scalb(half, 2); -- Will return “00010.” Or 2.0
someval := resize (scalb (half, X), someval’high, someval’low);
</pre></div>
</div>
<p>All of the standard compare functions are implemented in these packages.
=, /=, &lt;, &gt;, &gt;=, &lt;= perform in a similar way to the numeric_std functions.
If values of two different lengths are given, then the inputs are resized and the compare is then made.</p>
<p>The “maximum” and “minimum” functions do a compare operation and return the appropriate value.
These functions are not overloaded for integer and real inputs.
The size of the inputs does not need to match.</p>
<p>The “find_leftmost” and “find_rightmost” functions are used to find the most significant bit or least
significant bit of a fixed-point number.
The function looks like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">find_leftmost</span> <span class="p">(</span><span class="n">arg</span> <span class="p">:</span> <span class="n">ufixed</span><span class="p">;</span> <span class="n">y</span> <span class="p">:</span> <span class="n">STD_ULOGIC</span><span class="p">)</span> <span class="k">return</span> <span class="n">INTEGER</span><span class="p">;</span>
</pre></div>
</div>
<p>In this case, “y” can be any “std_ulogic” value.
These functions search for the first occurrence of “y” in the fixed-point number.
“find_leftmost” starts at the MSB (arg’high) and goes down.
“find_leftmost” starts at the LSB (arg’low) and goes up.
If that value is not found in the “find_leftmost” function, “arg’low-1” is returned.
If the value is not found in the “find_rightmost” function, “arg’high+1” is
returned. Note that “find_leftmost (uf1, ‘1’) will return the integer log (base 2) of “uf1”.</p>
<p>“to_01” , “to_X01”, “Is_X”, “to_X01Z” and “to_UX01” are similar in function to the std_logic_1164 and numeric_std
functions with the same name.</p>
<p>Most synthesis tools do not support any I/O format other than “std_logic_vector” and “std_logic”.
Thus, functions have been created to convert between std_logic_vector and ufixed or sfixed and vice versa:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>uf7_3 &lt;= to_ufixed (slv7, uf7_3’high, uf7_3’low);
</pre></div>
</div>
<p>and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">slv7</span> <span class="o">&lt;=</span> <span class="n">to_slv</span> <span class="p">(</span><span class="n">uf7_3</span><span class="p">);</span>
</pre></div>
</div>
<p>One of the changes made to all packages in VHDL-2006 is that the read and write routines for all data types are
now defined in the same package that defines that type.
Thus, the READ, WRITE, HREAD, HWRITE, OREAD, and OWRITE routines are defined for fixed-point data types.
A “.” separator is added between the integer part and the fractional part of the fixed-point number.
Therefore the “6.5” example from above will write as “00110.10000”, which you can also read back into that data
type.</p>
<p>New to vhdl-2006 are the functions “to_string”, “to_ostring”, and “to_hstring”.
These are very useful in “assert” statements. Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>assert x=y
report to_string(x) &amp; “ /= “ &amp; to_string(y) severity error;
</pre></div>
</div>
<p>Or, if you prefer to see the numbers as “real” numbers, you can use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>assert x=y
report to_string(to_real(x)) &amp; “ /= “ &amp; to_string(to_real(y))
severity error;
</pre></div>
</div>
<p>These days, MathWorks Simulink is the most common way to define a fixed-point DSP algorithm.
Simulink seems to be a major step into the past because it is schematic based.
In Simulink, an unsigned fixed-point number is described as ufix[14,10], which specifies a 14-bit long word with
10 bits after the fraction.
This translates into “ufixed (3 downto –10)” in the unsigned fixed-point type.
The Simulink “sfix” notation translates much better because of the extra sign bit that must be generated.
<code class="docutils literal notranslate"><span class="pre">Sfix(14,</span> <span class="pre">10)</span></code> will translate into <code class="docutils literal notranslate"><span class="pre">sfixed(3</span> <span class="pre">downto</span> <span class="pre">–10)</span></code> in the notation of the “fixed_pkg”.</p>
</section>
<section id="package-generics">
<h2>Package Generics<a class="headerlink" href="#package-generics" title="Permalink to this heading">¶</a></h2>
<p>These packages are done using something new in VHDL-200X called package generics.
“fixed_generic_pkg.vhd” contains the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">use</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">fixed_float_types</span><span class="o">.</span><span class="n">all</span><span class="p">;</span>
<span class="n">package</span> <span class="n">fixed_generic_pkg</span> <span class="ow">is</span>
<span class="n">generic</span> <span class="p">(</span>
<span class="o">--</span> <span class="n">Round</span> <span class="n">style</span><span class="p">,</span> <span class="n">fixed_round</span> <span class="p">(</span><span class="n">do</span> <span class="n">rounding</span><span class="p">),</span> <span class="n">fixed_truncate</span> <span class="p">(</span><span class="n">truncate</span><span class="p">)</span>
<span class="n">fixed_round_style</span> <span class="p">:</span> <span class="n">fixed_round_style_type</span> <span class="o">:=</span> <span class="n">fixed_round</span><span class="p">;</span>
<span class="o">--</span> <span class="n">Overflow</span> <span class="n">style</span><span class="p">,</span> <span class="n">fixed_saturate</span> <span class="p">(</span><span class="n">largest</span> <span class="n">possible</span> <span class="n">number</span><span class="p">),</span>
<span class="o">--</span> <span class="n">fixed_wrap</span> <span class="p">(</span><span class="n">discard</span> <span class="n">high</span> <span class="n">bits</span><span class="p">)</span>
<span class="n">fixed_overflow_style</span> <span class="p">:</span> <span class="n">fixed_overflow_style_type</span> <span class="o">:=</span> <span class="n">fixed_saturate</span><span class="p">;</span>
<span class="o">--</span> <span class="n">Guard</span> <span class="n">bits</span> <span class="n">are</span> <span class="n">added</span> <span class="n">to</span> <span class="n">the</span> <span class="n">bottom</span> <span class="n">of</span> <span class="n">some</span> <span class="n">operation</span> <span class="k">for</span> <span class="n">rounding</span><span class="o">.</span>
<span class="o">--</span> <span class="nb">any</span> <span class="n">natural</span> <span class="n">number</span> <span class="p">(</span><span class="n">including</span> <span class="mi">0</span><span class="p">)</span> <span class="n">are</span> <span class="n">valid</span><span class="o">.</span>
<span class="n">fixed_guard_bits</span> <span class="p">:</span> <span class="n">NATURAL</span> <span class="o">:=</span> <span class="mi">3</span><span class="p">;</span>
<span class="o">--</span> <span class="n">when</span> <span class="s2">&quot;false&quot;</span> <span class="n">issue</span> <span class="n">warnings</span><span class="p">,</span> <span class="n">when</span> <span class="s2">&quot;true&quot;</span> <span class="n">be</span> <span class="n">silent</span><span class="o">.</span>
<span class="n">no_warning</span> <span class="p">:</span> <span class="n">BOOLEAN</span> <span class="o">:=</span> <span class="n">false</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Due to the way package generics work, “fixed_generic_pkg” can not be instantiated.
However another package called “fixed_pkg” is provided. This package looks like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">fixed_pkg</span> <span class="ow">is</span>
<span class="n">new</span> <span class="n">work</span><span class="o">.</span><span class="n">fixed_generic_pkg</span>
<span class="n">generic</span> <span class="nb">map</span> <span class="p">(</span>
<span class="n">fixed_round_style</span> <span class="o">=&gt;</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">fixed_float_types</span><span class="o">.</span><span class="n">fixed_round</span><span class="p">,</span>
<span class="n">fixed_overflow_style</span> <span class="o">=&gt;</span> <span class="n">IEEE</span><span class="o">.</span><span class="n">fixed_float_types</span><span class="o">.</span><span class="n">fixed_saturate</span><span class="p">,</span>
<span class="n">fixed_guard_bits</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="o">--</span> <span class="n">number</span> <span class="n">of</span> <span class="n">guard</span> <span class="n">bits</span>
<span class="n">no_warning</span> <span class="o">=&gt;</span> <span class="n">false</span> <span class="o">--</span> <span class="n">show</span> <span class="n">warnings</span>
<span class="p">);</span>
</pre></div>
</div>
<p>This is where the defaults get set.
Note that the user can now create his/her own version of the fixed point package if the defaults are not what they
desire.</p>
<p>Example:
I don’t want to round (takes up too much logic), I want to truncate numbers, not saturate them, I don’t need
guard bits on my division routines, and I want those silly “metavalue detected” warnings turned off. Easy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>package my_fixed_pkg is
new ieee.fixed_generic_pkg
generic map (
-- Truncate, don’t round
fixed_round_style =&gt; IEEE.fixed_float_types.fixed_truncate,
-- wrap, don’t saturate
fixed_overflow_style =&gt; IEEE.fixed_float_types.fixed_wrap,
fixed_guard_bits =&gt; 0, -- Don’t need the extra guard bits
no_warning =&gt; true -- turn warnings off
);
</pre></div>
</div>
<p>Now you can compile this file into your code.
You will have to do a “use work.my_fixed_pkg.all;” to make the fixed point function visible.
If you need to translate back to the IEEE “fixed_pkg” types, you can do that with type casting as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>use IEEE.fixed_pkg.all;
entity sin is
port (
arg : in ufixed (1 downto -16);
clk, rst : in std_ulogic;
res : out ufixed (1 downto -11));
end entity sin;

architecture structure of sin is
component fixed_sin is
port (
arg : in work.my_fixed_pkg.ufixed (1 downto -16);
clk, rst : in STD_ULOGIC;
res : out work.my_fixed_pkg.ufixed (1 downto -11));
end component fixed_sin;
signal resx : work.my_fixed_pkg.ufixed (1 downto -11);
begin
U1: fixed_sin
port map (
arg =&gt; work.my_fixed_pkg.ufixed(arg), -- convert “arg”
clk =&gt; clk,
rst =&gt; rst,
res =&gt; resx);
res &lt;= ieee.fixed_pkg.ufixed (resx);
end architecture structure;
</pre></div>
</div>
</section>
<section id="issues">
<h2>Issues<a class="headerlink" href="#issues" title="Permalink to this heading">¶</a></h2>
<p>The fixed-point math packages are based on the VHDL 1076.3 numeric_std package and use the signed and unsigned
arithmetic from within that package.
This makes them highly efficient because the numeric_std package is well supported by simulation and synthesis
tools.</p>
<p>A negative or “to” index is flagged as an error by the fixed-point routines.
Thus, if you define a number as <code class="docutils literal notranslate"><span class="pre">ufixed</span> <span class="pre">(1</span> <span class="pre">to</span> <span class="pre">5)</span></code> the routines will automatically error out.
String literals are also a problem.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>By default, if you do the following:
Z &lt;= a + “011011”;
</pre></div>
</div>
<p>the index of the fixed-point number is undefined.
The VHDL compiler will assume that the range of this number has the range “integer’low to integer’low+5”, making
it a very very small number.
To avoid crashing the simulator with a 32,000-bit-wide number, this will also automatically error out.
Another case to watch for is the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>signal a : sfixed (3 downto –3);
signal b : sfixed (2 downto –4);
begin
b &lt;= a;
</pre></div>
</div>
<p>In this case, you have two vectors of the same length.
VHDL allows you to automatically go from one type to another as long as they are of the same base type and width.
This causes problems for the fixed point routines.
You can easily accidentaly turn 6.5 into 3.25 by doing this and not know that you have done it.</p>
</section>
<section id="index">
<h2>Index<a class="headerlink" href="#index" title="Permalink to this heading">¶</a></h2>
<section id="operators">
<h3>Operators<a class="headerlink" href="#operators" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>“+” - Add two fixed-point numbers together, overloaded for real and integer. See output sizing rules.</p></li>
<li><p>“-” – Subtracts fixed-point numbers. Overloaded for real and integer. See output sizing rules. Unary version</p></li>
</ul>
<p>(- var1) version returns a value that is one bit larger than the input. Note that unary “-“ is only
implemented on “sfixed”.</p>
<ul class="simple">
<li><p>“*” – Multiply two fixed-point numbers together. Overloaded for real and integer. See output sizing rules.</p></li>
<li><p>“/” – Divides two fixed-point numbers. Overloaded for real and integer. See output sizing rules. Uses 3</p></li>
</ul>
<p>guard bits and rounds the result by default. If this is not the desired functionality, then use the “divide”
function, or modify the package generics.</p>
<ul class="simple">
<li><p>“abs” – Absolute. Returns a result one bit larger than the input. There are two versions of this operator.</p></li>
</ul>
<p>Both take in an “sfixed”.</p>
<ul class="simple">
<li><p>“mod” – modulo. Returns the signed remainder. See sizing rules for the size of the result. Overloaded for</p></li>
</ul>
<p>real and integer.</p>
<ul class="simple">
<li><p>“rem” – Remainder. Returns the unsigned remainder. See sizing rules for the size of the result. Overloaded</p></li>
</ul>
<p>for real and integer.</p>
<ul class="simple">
<li><p>“sll” – Shift left logical. Left argument is ufixed or sfixed, right argument is integer. A negative right</p></li>
</ul>
<p>argument causes a logical right shift.</p>
<ul class="simple">
<li><p>“srl” – Shift right logical. Left argument is ufixed or sfixed, right argument is integer. A negative right</p></li>
</ul>
<p>argument causes a logical left shift.</p>
<ul class="simple">
<li><p>“rol” – Rotate logical left. Left argument is ufixed or sfixed, right argument is integer. A negative right</p></li>
</ul>
<p>argument causes a rotate right.</p>
<ul class="simple">
<li><p>“ror” – Rotate logical right. Left argument is ufixed or sfixed, right argument is integer. A negative right</p></li>
</ul>
<p>argument causes a rotate left.</p>
<ul class="simple">
<li><p>“sla” – Shift left arithmetic. Left argument is ufixed or sfixed, right argument is integer. A negative right</p></li>
</ul>
<p>argument causes right arithmetic shift. Note that a right arithmetic shift on an “sfixed” replicates the sign
bit. A left shift does not replicate the LSB. Note that “x sla int” will multiply (or divide) X by a power of
2.</p>
<ul class="simple">
<li><p>“sra” – Shift right arithmetic. Left argument is ufixed or sfixed, right argument is integer. A negative right</p></li>
</ul>
<p>argument causes left arithmetic shift. Note that a right arithmetic shift on an “sfixed” replicates the sign
bit. A left shift does not replicate the LSB. Note that “x sra int” will divide (or multiply) X by a power of
2.</p>
<ul class="simple">
<li><p>“=” – equal. Overloaded for real and integer. Returns a “false” if any “X” is found. Integers are converted</p></li>
</ul>
<p>to fixed point with to_fixed (arg, max(a’high+1, 0), 0), Reals are converted with to_fixed (arg, a’high+1,
a’low) and rounded.</p>
<ul class="simple">
<li><p>“/=”– not equal. Overloaded for real and integer. Returns a “true” if any “X” is found.. Integers are</p></li>
</ul>
<p>converted to fixed point with to_fixed (arg, max(a’high+1, 0), 0), Reals are converted with to_fixed (arg,
a’high+1, a’low) and rounded.</p>
<ul class="simple">
<li><p>“&lt;”– less than. Overloaded for real and integer. Returns a “false” if any “X” is found . Integers are</p></li>
</ul>
<p>converted to fixed point with to_fixed (arg, max(a’high+1, 0), 0), Reals are converted with to_fixed (arg,
a’high+1, a’low) and rounded.</p>
<ul class="simple">
<li><p>“&gt;”– greater than. Overloaded for real and integer. Returns a “false” if any “X” is found. . Integers are</p></li>
</ul>
<p>converted to fixed point with to_fixed (arg, max(a’high+1, 0), 0), Reals are converted with to_fixed (arg,
a’high+1, a’low) and rounded.</p>
<ul class="simple">
<li><p>“&lt;=”– less than or equal to. Overloaded for real and integer. Returns a “false” if any “X” is found.</p></li>
</ul>
<p>Integers are converted to fixed point with to_fixed (arg, max(a’high+1, 0), 0), Reals are converted with
to_fixed (arg, a’high+1, a’low) and rounded.</p>
<ul class="simple">
<li><p>“&gt;=”– greater than or equal to. Overloaded for real and integer. Returns a “false” if any “X” is found.</p></li>
</ul>
<p>Integers are converted to fixed point with to_fixed (arg, max(a’high+1, 0), 0), Reals are converted with
to_fixed (arg, a’high+1, a’low) and rounded.</p>
<ul class="simple">
<li><p>“?=” - Performs an operation similar to the “numeric_std.std_match” function, but returns an std_ulogic</p></li>
</ul>
<p>value. The VHDL-93 compatible version of this function is “?=”</p>
<ul class="simple">
<li><p>“?/=” - Performs an operation similar to the inverse of the “numeric_std.std_match” function, but returns</p></li>
</ul>
<p>an std_ulogic value. The VHDL-93 compatible version of this function is “?/=”</p>
<ul class="simple">
<li><p>“?&lt;” - Returns an “X” if a metavalue is in either number, a “1” if L is less than R, otherwise ‘0”. The</p></li>
</ul>
<p>VHDL-93 compatible version of this function is “?&lt;”</p>
<ul class="simple">
<li><p>“?&lt;=” - Returns an “X” if a metavalue is in either number, a “1” if L is less than or equal to R, otherwise</p></li>
</ul>
<p>‘0”. The VHDL-93 compatible version of this function is “?&lt;=”</p>
<ul class="simple">
<li><p>“?&gt;” - Returns an “X” if a metavalue is in either number, a “1” if L is greater than R, otherwise ‘0”. The</p></li>
</ul>
<p>VHDL-93 compatible version of this function is “?&gt;”</p>
<ul class="simple">
<li><p>“?&gt;=” - Returns an “X” if a metavalue is in either number, a “1” if L is greater than or equal to R,</p></li>
</ul>
<p>otherwise ‘0”. The VHDL-93 compatible version of this function is “?&gt;=”</p>
<ul class="simple">
<li><p>“not” – Logical not</p></li>
<li><p>“and” –logical and. There are 3 versions of this operator. “vector op vector”, “vector op std_ulogic”, and</p></li>
</ul>
<p>“op vector”. The “vector op vector” version operates on each bit of the vector independently. “vector op
std_ulogic” performs the operation on every bit of the vector with the “std_ulogic”. The “op vector”
version performs a reduction operation and returns a single bit. The vhdl-2002 version of this function is
“and_reduce”. An “op vector” with a null array returns a “1”.</p>
<ul class="simple">
<li><p>“nand” –logical nand. There are 3 versions of this operator. “vector op vector”, “vector op std_ulogic”, and</p></li>
</ul>
<p>“op vector”. The “vector op vector” version operates on each bit of the vector independently. “vector op
std_ulogic” performs the operation on every bit of the vector with the “std_ulogic”. The “op vector”
version performs a reduction operation and returns a single bit. The vhdl-2002 version of this function is
“nand_reduce”. An “op vector” with a null array returns a “0”.</p>
<ul class="simple">
<li><p>“or” –logical or. There are 3 versions of this operator. “vector op vector”, “vector op std_ulogic”, and “op</p></li>
</ul>
<p>vector”. The “vector op vector” version operates on each bit of the vector independently. “vector op
std_ulogic” performs the operation on every bit of the vector with the “std_ulogic”. The “op vector”
version performs a reduction operation and returns a single bit. The vhdl-2002 version of this function is
“or_reduce”. An “op vector” with a null array returns a “0”.</p>
<ul class="simple">
<li><p>“nor” –logical nor. There are 3 versions of this operator. “vector op vector”, “vector op std_ulogic”, and</p></li>
</ul>
<p>“op vector”. The “vector op vector” version operates on each bit of the vector independently. “vector op
std_ulogic” performs the operation on every bit of the vector with the “std_ulogic”. The “op vector”
version performs a reduction operation and returns a single bit. The vhdl-2002 version of this function is
“nor_reduce”. An “op vector” with a null array returns a “0”.</p>
<ul class="simple">
<li><p>“xor” –logical exclusive or. There are 3 versions of this operator. “vector op vector”, “vector op</p></li>
</ul>
<p>std_ulogic”, and “op vector”. The “vector op vector” version operates on each bit of the vector
independently. “vector op std_ulogic” performs the operation on every bit of the vector with the
“std_ulogic”. The “op vector” version performs a reduction operation and returns a single bit. The vhdl-
2002 version of this function is “xor_reduce”. An “op vector” with a null array returns a “0”.</p>
<ul class="simple">
<li><p>“xnor” –logical exclusive nor. There are 3 versions of this operator. “vector op vector”, “vector op</p></li>
</ul>
<p>std_ulogic”, and “op vector”. The “vector op vector” version operates on each bit of the vector
independently. “vector op std_ulogic” performs the operation on every bit of the vector with the
“std_ulogic”. The “op vector” version performs a reduction operation and returns a single bit. The vhdl-
2002 version of this function is “xnor_reduce”. An “op vector” with a null array returns a “1”.</p>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Find_leftmost – find most significant bit. Inputs: arg (ufixed or sfixed), y : std_ulogic. Returns the integer</p></li>
</ul>
<p>index of the first occurrence of “y” in the vector “arg” starting from the MSB. Arg’low-1 is returned if “y”
is not found. Note that find_msb(x, ‘1’) will return the integer log base 2 of the input “x”.</p>
<ul class="simple">
<li><p>Find_rightmost – find least significant bit. Inputs: arg (ufixed or sfixed), y : std_ulogic. Returns the integer</p></li>
</ul>
<p>index of the first occurrence of “y” in the vector “arg” starting from the LSB. Arg’high+1 is returned if “y”
is not found.</p>
<ul class="simple">
<li><p>Divide – arithmetic divide. Functionally identical to the “/” operator, but with two extra parameters.</p></li>
</ul>
<p>Inputs: l, r (both ufixed or sfixed), Parameters: guard_bits : natural, round_style : Boolean. See output
sizing rules. “guard_bits” defaults to 3, these are extra bits that are added to the end of the divide routine to
maintain precision when rounding. “round_style” (default true) is a Boolean that can be used to turn on or
off rounding. If rounding is set to false, then the guard bits are ignored.
Reciprocal: Performs a 1/arg function. Inputs: arg (ufixed or sfixed), guard_bits : natural, round_style :
Boolean. See output sizing rules. “guard_bits” defaults to 3, these are extra bits that are added to the end of
the divide routine to maintain precision when rounding. “round_style” (default true) is a Boolean that can
be used to turn on or off rounding. If rounding is set to false, then the guard bits are ignored.</p>
<ul class="simple">
<li><p>Minimum – returns the minimum of the two inputs (both either ufixed or sfixed) by performing a “&gt;”</p></li>
</ul>
<p>operation.</p>
<ul class="simple">
<li><p>maximum– returns the maximum of the two inputs (both either ufixed or sfixed) by performing a “&gt;”</p></li>
</ul>
<p>operation.</p>
<ul class="simple">
<li><p>Std_match – Performs a “numeric_std.std_match” function (allows you to use “-“ values on the inputs).</p></li>
<li><p>add_carry – This is a VHDL procedure which takes in two arguments (L and R) as well as a carry_in</p></li>
</ul>
<p>(C_IN) and return a carry out (C_OUT) as well as a result of the same length as the combined width of L
and R. Note that this routine can be use as an accumulator.</p>
<ul class="simple">
<li><p>Scalb – Inputs are ufixed or sfixed, with an integer or signed input. The Scalb function moved the index of</p></li>
</ul>
<p>the fixed point number, having the effect of multiplying or dividing by a power of two.</p>
</section>
<section id="conversion-functions">
<h3>Conversion functions<a class="headerlink" href="#conversion-functions" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Resize – Changes the size of a “ufixed” or “sfixed” (larger or smaller). Inputs: arg (ufixed or sfixed),</p></li>
</ul>
<p>left_index and right_index (integer) OR size_res (same type as “arg”).
Parameters: round_style : Boolean (true), saturate_style : Boolean (true). Output: resized “ufixed” or
“sfixed”.</p>
<ul class="simple">
<li><p>To_ufixed – Converts to the “ufixed” type.</p></li>
<li><p>To_ufixed (std_logic_vector) Inputs: arg (std_logic_vector) , left_index and right_index (integer)</p></li>
</ul>
<p>OR size_res (ufixed). – This is a conversion function that will convert a std_logic_vector into a
ufixed with the same width. A warning is produced if the width is incorrect.</p>
<blockquote>
<div><ul class="simple">
<li><p>To_ufixed (std_ulogic_vector) Inputs: arg (std_ulogic_vector) , left_index and right_index</p></li>
</ul>
</div></blockquote>
<p>(integer) OR size_res (ufixed). – This is a conversion function that will convert a
std_ulogic_vector into a ufixed with the same width. A warning is produced if the width is
incorrect.</p>
<blockquote>
<div><ul class="simple">
<li><p>To_ufixed (unsigned) Inputs: arg (unsigned) , left_index and right_index (integer) OR size_res</p></li>
</ul>
</div></blockquote>
<p>(ufixed). Parameters: round_style : Boolean, saturate_style – Converts an unsigned into a “ufixed”</p>
<blockquote>
<div><ul class="simple">
<li><p>To_ufixed (unsigned) Inputs: arg (unsigned) – Converts an unsigned into a ufixed of the same size</p></li>
</ul>
</div></blockquote>
<p>with the left_index being arg’length-1 and the right_index being 0.</p>
<blockquote>
<div><ul class="simple">
<li><p>To_ufixed (real) Inputs: arg (real) , left_index and right_index (integer) OR size_res (ufixed).</p></li>
</ul>
</div></blockquote>
<p>Parameters: round_style : Boolean, saturate_style – Converts a real into a “ufixed”. If the input is
negative then and error is produced and 0 is returned.</p>
<blockquote>
<div><ul class="simple">
<li><p>To_ufixed (integer) Inputs: arg (natural) , left_index and right_index (integer) OR size_res</p></li>
</ul>
</div></blockquote>
<p>(ufixed). Parameters: round_style : Boolean, saturate_style – Converts a integer into a “ufixed”</p>
<blockquote>
<div><ul class="simple">
<li><p>To_ufixed (sfixed) Inputs: arg (sfixed) - Converts and sfixed into a ufixed of the same size.</p></li>
</ul>
</div></blockquote>
<p>Performs an “abs” function if the input is negative.</p>
<ul class="simple">
<li><p>To_sfixed – Converts to the “sfixed” type.</p>
<ul>
<li><p>To_sfixed (std_logic_vector) Inputs: arg (std_logic_vector) , left_index and right_index (integer)</p></li>
</ul>
</li>
</ul>
<p>OR size_res (sfixed). Parameters: round_style : Boolean, saturate_style – This is a conversion
function which will convert a std_logic_vector into a sfixed with the same width. A warning is
produced if the width is incorrect.</p>
<blockquote>
<div><ul class="simple">
<li><p>To_sfixed (std_ulogic_vector) Inputs: arg (std_ulogic_vector) , left_index and right_index</p></li>
</ul>
</div></blockquote>
<p>(integer) OR size_res (sfixed). Parameters: round_style : Boolean, saturate_style – This is a
conversion function which will convert a std_ulogic_vector into a sfixed with the same width. A
warning is produced if the width is incorrect.</p>
<blockquote>
<div><ul class="simple">
<li><p>To_sfixed (signed) Inputs: arg (signed) , left_index and right_index (integer) OR size_res (ufixed).</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Parameters: round_style<span class="classifier">Boolean, saturate_style – Converts a signed into a “sfixed”</span></dt><dd><ul class="simple">
<li><p>To_sfixed (signed) Inputs: arg (signed) – Converts a signed into a sfixed of the same size with the</p></li>
</ul>
</dd>
<dt>left_index being arg’length-1 and the right_index being 0.</dt><dd><ul class="simple">
<li><p>To_sfixed (real) Inputs: arg (real) , left_index and right_index (integer) OR size_res (ufixed).</p></li>
</ul>
</dd>
<dt>Parameters: round_style<span class="classifier">Boolean, saturate_style – Converts a real into a “sfixed”.</span></dt><dd><ul class="simple">
<li><p>To_sfixed (integer) Inputs: arg (integer) , left_index and right_index (integer) OR size_res</p></li>
</ul>
</dd>
<dt>(ufixed). Parameters: round_style<span class="classifier">Boolean, saturate_style – Converts a integer into a “sfixed”</span></dt><dd><ul class="simple">
<li><p>To_sfixed (ufixed) Inputs: arg (ufixed) – Converts a “ufixed” into an “sfixed”. The result grows</p></li>
</ul>
</dd>
</dl>
<p>by one bit, so the resulting vector will be sfixed (arg’high+1 downto arg’low).</p>
<ul class="simple">
<li><p>To_unsigned - Inputs: arg (ufixed) and size (natural) OR size_res (unsigned). Parameters: round_style :</p></li>
</ul>
<p>Boolean, saturate_style – Converts a ufixed into an unsigned. This does not produce a “vector truncated”
warning as the ieee.numeric_std functions do.</p>
<ul class="simple">
<li><p>To_signed - Inputs: arg (sfixed) and size (natural) OR size_res (signed). Parameters: round_style :</p></li>
</ul>
<p>Boolean, saturate_style – Converts a sfixed into an signed. This does not produce a “vector truncated”
warning as the ieee.numeric_std functions do.</p>
<ul class="simple">
<li><p>To_real – inputs: arg (ufixed or sfixed). Converts a fixed-point number into a real number.</p></li>
<li><p>To_integer – inputs: arg (ufixed or sfixed), Parameters: round_style and saturate_style : Boolean. Converts</p></li>
</ul>
<p>a fixed-point number into an integer</p>
<ul class="simple">
<li><p>Add_sign – Inputs: arg(ufixed). Converts an unsigned fixed-point number (ufixed) into a signed fixed-</p></li>
</ul>
<p>point number (sfixed). This function grows the result by 1. There is an “abs” function that converts a
sfixed back to a ufixed.</p>
<ul class="simple">
<li><p>To_slv – Inputs: arg (ufixed or sfixed). Converts a fixed-point number into a std_logic_vector of the same</p></li>
</ul>
<p>length.</p>
<ul class="simple">
<li><p>To_std_logic_vector – alias of to_slv.</p></li>
<li><p>To_stdlogicvector – alias of to_slv</p></li>
<li><p>To_sulv – Inputs: arg (ufixed or sfixed). Converts a fixed-point number into a std_ulogic_vector of the</p></li>
</ul>
<p>same length.</p>
<ul class="simple">
<li><p>To_std_ulogic_vector – alias of to_sulv.</p></li>
<li><p>To_stdulogicvector – alias of to_sulv</p></li>
<li><p>To_01 – Inputs (s: ufixed or sfixed). Parameters: XMAP : std_ulogic. Converts metavalues in the vector S</p></li>
</ul>
<p>to the XMAP state (defaults to 0).</p>
<ul class="simple">
<li><p>Is_X – Inputs (arg: ufixed or sfixed) – returns a Boolean which is “true” if there are any metavalues in the</p></li>
</ul>
<p>vector “arg”.</p>
<ul class="simple">
<li><p>To_x01 – Inputs (arg: ufixed or sfixed) – Converts any metavalues found in the vector “arg” to be “X” ,</p></li>
</ul>
<p>“0”, or “1”.</p>
<ul class="simple">
<li><p>To_ux01 – Inputs (arg: ufixed or sfixed) – Converts any metavalues found in the vector “arg” to be “U”,</p></li>
</ul>
<p>“X” , “0”, or “1”.</p>
<ul class="simple">
<li><p>To_x01z – Inputs (arg: ufixed or sfixed) – Converts any metavalues found in the vector “arg” to be “Z”,</p></li>
</ul>
<p>“X” , “0”, or “1”.</p>
</section>
<section id="sizing-functions">
<h3>Sizing functions<a class="headerlink" href="#sizing-functions" title="Permalink to this heading">¶</a></h3>
<p>Each of these functions take as a parameter a character that is used to describe the operation to be performed.
They work as follows (table 1):</p>
<p>‘+’        “+”
‘-‘        “-”
‘*’        “*”
‘/’        “/”, divide
‘1’        reciprocal
‘M’ or ‘m’ “mod”, modulo
‘R’ or ‘r’ “rem”, remainder
‘A’ or ‘a’ abs
‘N’ or ‘n’ “-” - unary
others     index</p>
<ul class="simple">
<li><p>Ufixed_high – Inputs: left_index, right_index: integer (bounds of the left argument) or size_res: ufixed,</p></li>
</ul>
<p>operation : character, left_index2, right_index2 : integer (bounds of the left argument) or size_res2: ufixed.
This function us used to compute the width of an operation. If “operation” is set to “+”, then the result of
this function will be the ‘high value of the computed result. Any values for “operation” other than those
defined in table 1 cause the “left_index” to be returned.</p>
<ul class="simple">
<li><p>Ufixed_low– Inputs: left_index, right_index: integer (bounds of the left argument) or size_res: ufixed,</p></li>
</ul>
<p>operation : character, left_index2, right_index2 : integer (bounds of the left argument) or size_res2: ufixed.
This function us used to compute the width of an operation. If “operation” is set to “+”, then the result of
this function will be the ‘low value of the computed result. Any values for “operation” other than those
defined in table 1 cause the “right_index” to be returned.</p>
<ul class="simple">
<li><p>Sfixed_high– Inputs: left_index, right_index: integer (bounds of the left argument) or size_res: sfixed,</p></li>
</ul>
<p>operation : character, left_index2, right_index2 : integer (bounds of the left argument) or size_res2: sfixed.
This function us used to compute the width of an operation. If “operation” is set to “+”, then the result of
this function will be the ‘high value of the computed result. Any values for “operation” other than those
defined in table 1 cause the “left_index” to be returned.</p>
<ul class="simple">
<li><p>Sfixed_low– Inputs: left_index, right_index: integer (bounds of the left argument) or size_res: sfixed,</p></li>
</ul>
<p>operation : character, left_index2, right_index2 : integer (bounds of the left argument) or size_res2: sfixed.
This function us used to compute the width of an operation. If “operation” is set to “+”, then the result of
this function will be the ‘low value of the computed result. Any values for “operation” other than those
defined in table 1 cause the “right_index” to be returned.</p>
<ul class="simple">
<li><p>To_ufix – Similar to “to_ufixed”, but with natural arguments. Thus to_ufix (“00100”, 5, 3); = “00.100”, or</p></li>
</ul>
<p>0.5.</p>
<ul class="simple">
<li><p>To_sfix – Similar to “to_sfixed”, but with natural arguments. The sign bit is understood, thus:</p></li>
</ul>
<p>to_sfix(“00100”, 4, 3) = “00.100” or 0.5.</p>
<ul class="simple">
<li><p>Ufix_high – Similar to “ufixed_high”, but with natural numbers.</p></li>
<li><p>Ufix_low – Similar to “ufixed_low”, but with natural numbers.</p></li>
<li><p>Sfix_high – Similar to “sfixed_high”, but with signed numbers.</p></li>
<li><p>Sfix_low – Similar to “sfixed_low”, but with signed numbers.</p></li>
</ul>
</section>
<section id="textio-functions">
<h3>Textio Functions<a class="headerlink" href="#textio-functions" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Write – Similar to the textio “write” procedure. Automatically puts in a decimal point where needed. If the</p></li>
</ul>
<p>range of the input number does not include the “0” index then the number is extended until it does before
writing.</p>
<ul class="simple">
<li><p>Read – Similar to the textio “read” procedure. If a decimal point is encountered then it is tested to be sure</p></li>
</ul>
<p>that it is in the correct place.</p>
<ul class="simple">
<li><p>Bwrite – Alias to “write”</p></li>
<li><p>Bread – Alias to “read”</p></li>
<li><p>Owrite – Octal write. In this case the number is treated as two different numbers with a decimal point</p></li>
</ul>
<p>between them. Both sides of the number are padded so that the number winds up with a range that is
divisible by 3 on both sides. A “.” is written out to separate the integer portion from the fraction.</p>
<ul class="simple">
<li><p>Oread – Octal read. The number being red is treated as two different numbers with an optional decimal</p></li>
</ul>
<p>point between them. If the number being red does not have a size divisible by 3 on both sides of the
decimal place, then both sides are padded until it does. If a “.” is found in the input string then the index is
checked to make sure that it is in the correct place.</p>
<ul class="simple">
<li><p>Hwrite - Hex write. In this case the number is treated as two different numbers with a decimal point</p></li>
</ul>
<p>between them. Both sides of the number are padded so that the number winds up with a range that is
divisible by 4 on both sides. A “.” is written out to separate the integer portion from the fraction.</p>
<ul class="simple">
<li><p>Hread– hex read. The number being red is treated as two different numbers with an optional decimal point</p></li>
</ul>
<p>between them. If the number being red does not have a size divisible by 4 on both sides of the decimal
place, then both sides are padded until it does. If a “.” is found in the input string then the index is checked
to make sure that it is in the correct place.</p>
<ul class="simple">
<li><p>To_string – Returns a string that can be padded and left or right justified. Example:</p></li>
</ul>
<p>Assert (a = 1.5) report “Result was “ &amp; to_string (a) severity error;</p>
<ul class="simple">
<li><p>To_bstring – Alias to “to_string”.</p></li>
<li><p>To_ostring – Similar to to_string, but returns an octal value with a decimal point. The padding rules of the</p></li>
</ul>
<p>owrite procedure apply to this function.</p>
<ul class="simple">
<li><p>To_hstring – Similar to to_string, but returns a hex value with a decimal point. The padding fules of the</p></li>
</ul>
<p>hwrite procedure apply to this function.</p>
<ul class="simple">
<li><p>From_string – Allows you to translate a string (with a decimal point in it) into a fixed-point number.</p></li>
</ul>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Signal a : ufixed (3 downto –3);
Begin
A &lt;= from_string (“0000.000”, a’high, a’low);
A &lt;= from_string (“0001.000”, a);
A &lt;= from_string (“0000.100”); -- Works only if size is exact.
Note that this is typically not synthesizable (as it uses “string” type). However you can still do “A &lt;=
“0000000”;” which will synthesize.
</pre></div>
</div>
<ul class="simple">
<li><p>From_ostring – Same as “from_string”, but uses octal numbers. The “oread” padding rules apply in this</p></li>
</ul>
<p>function.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../ieee/contexts.html" class="btn btn-neutral float-left" title="Contexts" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="float.html" class="btn btn-neutral float-right" title="Floating-point package User’s Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Unai Martinez-Corral and contributors.</p>
  </div>Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/buildthedocs/sphinx.theme">theme</a>
    provided by <a href="https://buildthedocs.github.io">Build the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>